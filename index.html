<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PyMPC - Music Player Code</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 50%, #16213e 100%);
            color: #00ff41;
            line-height: 1.6;
            overflow-x: hidden;
            padding: 20px;
            min-height: 100vh;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: rgba(0, 0, 0, 0.8);
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0, 255, 65, 0.3);
            overflow: hidden;
            backdrop-filter: blur(10px);
            border: 2px solid #00ff41;
        }

        /* Animated background grid */
        .bg-grid {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: 
                linear-gradient(rgba(0, 255, 65, 0.1) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 255, 65, 0.1) 1px, transparent 1px);
            background-size: 50px 50px;
            animation: gridMove 20s linear infinite;
            z-index: -1;
        }

        @keyframes gridMove {
            0% { transform: translate(0, 0); }
            100% { transform: translate(50px, 50px); }
        }

        .header {
            background: linear-gradient(135deg, #0a0a0a, #1a1a2e);
            color: #00ff41;
            padding: 30px;
            text-align: center;
            position: relative;
        }

        .header h1 {
            font-size: 4rem;
            margin-bottom: 10px;
            font-weight: 700;
            text-shadow: 0 0 20px #00ff41;
            animation: glow 2s ease-in-out infinite alternate;
        }

        @keyframes glow {
            from { text-shadow: 0 0 20px #00ff41; }
            to { text-shadow: 0 0 30px #00ff41, 0 0 40px #00ff41; }
        }

        .header p {
            font-size: 1.5rem;
            color: #66ff66;
            margin-bottom: 1rem;
        }

        .code-container {
            position: relative;
            margin: 30px;
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.15);
        }

        .code-header {
            background: linear-gradient(90deg, #00ff41, #66ff66);
            padding: 15px 20px;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .window-controls {
            display: flex;
            gap: 8px;
        }

        .control {
            width: 12px;
            height: 12px;
            border-radius: 50%;
        }

        .control.close { background: #ff4444; }
        .control.minimize { background: #ffaa00; }
        .control.maximize { background: #00ff41; }

        .filename {
            color: #000;
            font-weight: 600;
            font-size: 0.9rem;
        }

        .copy-btn {
            background: rgba(0, 0, 0, 0.3);
            border: none;
            color: #000;
            padding: 8px 16px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.8rem;
            transition: all 0.3s ease;
            font-weight: bold;
        }

        .copy-btn:hover {
            background: rgba(0, 0, 0, 0.5);
            transform: translateY(-1px);
        }

        .code-block {
            background: #1e1e1e;
            color: #d4d4d4;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.6;
            padding: 20px;
            overflow: auto;
            max-height: 70vh;
            white-space: pre;
            scrollbar-width: thin;
            scrollbar-color: #555 #2d2d2d;
        }

        .code-block::-webkit-scrollbar {
            width: 12px;
            height: 12px;
        }

        .code-block::-webkit-scrollbar-track {
            background: #2d2d2d;
        }

        .code-block::-webkit-scrollbar-thumb {
            background: #00ff41;
            border-radius: 6px;
        }

        .code-block::-webkit-scrollbar-thumb:hover {
            background: #66ff66;
        }

        .code-block::-webkit-scrollbar-corner {
            background: #2d2d2d;
        }

        /* Syntax highlighting */
        .keyword { color: #569cd6; }
        .string { color: #ce9178; }
        .comment { color: #6a9955; font-style: italic; }
        .function { color: #dcdcaa; }
        .class { color: #4ec9b0; }
        .number { color: #b5cea8; }
        .operator { color: #d4d4d4; }

        .line-numbers {
            position: absolute;
            left: 0;
            top: 0;
            padding: 20px 10px;
            background: rgba(0, 0, 0, 0.3);
            color: #858585;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.6;
            user-select: none;
            border-right: 1px solid #3e3e3e;
        }

        .code-content {
            margin-left: 60px;
        }

        /* Download section */
        .download-section {
            text-align: center;
            padding: 4rem 2rem;
            background: rgba(0, 0, 0, 0.8);
            border-radius: 20px;
            margin: 3rem 2rem;
            border: 2px solid #00ff41;
            position: relative;
            overflow: hidden;
        }

        .download-section::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(45deg, transparent, rgba(0, 255, 65, 0.05), transparent);
            animation: downloadShine 3s ease-in-out infinite;
        }

        @keyframes downloadShine {
            0% { transform: translateX(-100%) translateY(-100%) rotate(45deg); }
            50% { transform: translateX(0%) translateY(0%) rotate(45deg); }
            100% { transform: translateX(100%) translateY(100%) rotate(45deg); }
        }

        .download-btn {
            display: inline-block;
            background: linear-gradient(45deg, #00ff41, #66ff66);
            color: #000;
            padding: 1.5rem 3rem;
            font-size: 1.5rem;
            font-weight: bold;
            text-decoration: none;
            border-radius: 50px;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
            margin: 1rem;
            z-index: 1;
            font-family: 'Courier New', monospace;
        }

        .download-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            transition: left 0.5s;
        }

        .download-btn:hover::before {
            left: 100%;
        }

        .download-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 10px 30px rgba(0, 255, 65, 0.5);
            background: linear-gradient(45deg, #66ff66, #00ff41);
        }

        /* Specs */
        .specs {
            background: rgba(0, 0, 0, 0.8);
            padding: 2rem;
            border-radius: 10px;
            border: 1px solid #00ff41;
            margin: 2rem;
        }

        .specs h3 {
            color: #00ff41;
            margin-bottom: 1rem;
            font-size: 1.5rem;
            text-shadow: 0 0 10px #00ff41;
        }

        .specs ul {
            list-style: none;
            padding-left: 0;
        }

        .specs li {
            padding: 0.5rem 0;
            border-bottom: 1px solid #333;
            color: #ccc;
        }

        .specs li:before {
            content: "▶ ";
            color: #00ff41;
        }

        .features {
            padding: 30px;
            background: rgba(0, 0, 0, 0.6);
        }

        .features h2 {
            color: #00ff41;
            margin-bottom: 20px;
            font-size: 1.8rem;
            text-shadow: 0 0 10px #00ff41;
        }

        .feature-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
        }

        .feature-card {
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 5px 15px rgba(0, 255, 65, 0.2);
            transition: all 0.3s ease;
            border: 1px solid #00ff41;
            position: relative;
            overflow: hidden;
        }

        .feature-card::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(45deg, transparent, rgba(0, 255, 65, 0.1), transparent);
            transform: rotate(45deg);
            transition: all 0.5s;
            opacity: 0;
        }

        .feature-card:hover::before {
            animation: shine 1s ease-in-out;
        }

        @keyframes shine {
            0% { transform: translateX(-100%) translateY(-100%) rotate(45deg); opacity: 0; }
            50% { opacity: 1; }
            100% { transform: translateX(100%) translateY(100%) rotate(45deg); opacity: 0; }
        }

        .feature-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 20px 40px rgba(0, 255, 65, 0.4);
            border-color: #66ff66;
        }

        .feature-card h3 {
            color: #66ff66;
            margin-bottom: 10px;
        }

        .feature-card p {
            color: #ccc;
            line-height: 1.6;
        }

        /* Floating music notes */
        .music-note {
            position: fixed;
            color: #00ff41;
            font-size: 2rem;
            opacity: 0.3;
            pointer-events: none;
            animation: float 6s ease-in-out infinite;
        }

        @keyframes float {
            0%, 100% { transform: translateY(0) rotate(0deg); }
            25% { transform: translateY(-20px) rotate(5deg); }
            50% { transform: translateY(-10px) rotate(-5deg); }
            75% { transform: translateY(-30px) rotate(3deg); }
        }

        .music-note:nth-child(1) { top: 10%; left: 5%; animation-delay: 0s; }
        .music-note:nth-child(2) { top: 20%; right: 10%; animation-delay: 1s; }
        .music-note:nth-child(3) { top: 60%; left: 8%; animation-delay: 2s; }
        .music-note:nth-child(4) { top: 80%; right: 5%; animation-delay: 3s; }

        @media (max-width: 768px) {
            body {
                padding: 10px;
            }
            
            .header h1 {
                font-size: 2.5rem;
            }
            
            .code-container {
                margin: 15px;
            }
            
            .code-block {
                font-size: 12px;
                max-height: 50vh;
            }
        }
    </style>
</head>
<body>
    <div class="bg-grid"></div>
    
    <!-- Floating music notes -->
    <div class="music-note">♪</div>
    <div class="music-note">♫</div>
    <div class="music-note">♪</div>
    <div class="music-note">♫</div>

    <div class="container">
        <div class="header">
            <h1>🎵 PyMPC - Music Player</h1>
            <p>Terminal-based music player with playlist support built with Python, Pygame & Textual</p>
        </div>

        <div class="code-container">
            <div class="code-header">
                <div class="window-controls">
                    <div class="control close"></div>
                    <div class="control minimize"></div>
                    <div class="control maximize"></div>
                </div>
                <span class="filename">pympc.py</span>
                <button class="copy-btn" onclick="copyCode()">📋 Copy Code</button>
            </div>
            
            <div class="code-block" id="codeBlock">#!/usr/bin/env python3
"""
PyMPC - Pygame Music Player with Playlist Support
Robust terminal-based player with full audio and playlist support
"""

import os
import sys
import time
import platform
from pathlib import Path
from typing import List, Dict, Optional, Set, Tuple
import argparse
import threading
from enum import Enum
import json
import random

# Platform-specific audio configuration
if platform.system() == "Windows":
    os.environ["SDL_AUDIODRIVER"] = "directsound"
elif platform.system() == "Darwin":
    os.environ["SDL_AUDIODRIVER"] = "coreaudio"
else:
    os.environ["SDL_AUDIODRIVER"] = "alsa"

try:
    import pygame
    from pygame import mixer
    from textual import on, work
    from textual.app import App, ComposeResult
    from textual.widgets import (
        Header, Footer, DataTable, Static, Button,
        ProgressBar, Input, Select
    )
    from textual.containers import Horizontal, Vertical
    from textual.screen import ModalScreen
    from textual.message import Message
    from textual.reactive import reactive
    from mutagen import File as MutagenFile
    from mutagen.easyid3 import EasyID3
    from mutagen.id3 import ID3NoHeaderError
    from mutagen.flac import FLAC
    from mutagen.oggopus import OggOpus
    from mutagen.oggvorbis import OggVorbis
except ImportError as e:
    print(f"Missing dependency: {e}")
    print("Install with: pip install pygame textual mutagen")
    sys.exit(1)


# Configuration Manager
class MusicConfig:
    def __init__(self):
        self.config_path = self.get_config_path()
        self.data = self.load_config()

    def get_config_path(self) -> Path:
        """Get OS-appropriate config path"""
        if platform.system() == "Windows":
            base = Path(os.environ.get('APPDATA', Path.home()))
        else:
            base = Path.home() / ".config"
        return base / "pympc" / "config.json"

    def load_config(self) -> Dict:
        """Load or create configuration"""
        defaults = {
            'volume': 75,
            'music_dirs': [
                str(Path.home() / "Music"),
                str(Path.home() / "Downloads")
            ],
            'supported_formats': ['.mp3', '.wav', '.ogg', '.flac', '.m4a'],
            'buffer_size': 4096,
            'audio_channels': 2,
            'playlists': {},
            'current_playlist': None,
            'shuffle_mode': False,
            'repeat_mode': 0
        }

        try:
            self.config_path.parent.mkdir(parents=True, exist_ok=True)
            if self.config_path.exists():
                with open(self.config_path, 'r') as f:
                    loaded = json.load(f)
                    # Merge with defaults to handle new config options
                    defaults.update(loaded)
                    return defaults
            self.save_config(defaults)
            return defaults
        except Exception as e:
            print(f"Config error: {e}, using defaults")
            return defaults

    def save_config(self, data=None):
        """Save current configuration to file"""
        try:
            with open(self.config_path, 'w') as f:
                json.dump(data or self.data, f, indent=2)
        except Exception as e:
            print(f"Error saving config: {e}")

    @property
    def volume(self) -> float:
        return self.data['volume'] / 100.0

    @property
    def music_dirs(self) -> List[Path]:
        return [Path(p) for p in self.data['music_dirs']]

    @property
    def supported_suffixes(self) -> Set[str]:
        return set(self.data['supported_formats'])

    @property
    def playlists(self) -> Dict[str, List[str]]:
        return self.data.get('playlists', {})

    def save_playlist(self, name: str, tracks: List['MusicTrack']):
        self.data['playlists'][name] = [str(t.path) for t in tracks]
        self.save_config()


# Audio Track Handling
class MusicTrack:
    def __init__(self, path: Path):
        self.path = path
        self.title = path.stem
        self.artist = "Unknown Artist"
        self.duration = 0
        self._load_metadata()

    def _load_metadata(self):
        """Load audio metadata with format-specific handling"""
        try:
            if self.path.suffix.lower() == '.mp3':
                try:
                    audio = EasyID3(self.path)
                except ID3NoHeaderError:
                    audio = None
            else:
                audio = MutagenFile(self.path)

            if audio:
                self.title = self._get_tag(audio, 'title', self.path.stem)
                self.artist = self._get_tag(audio, 'artist', "Unknown Artist")
                self.duration = audio.info.length if hasattr(audio, 'info') else 0
        except Exception as e:
            print(f"Metadata error for {self.path}: {e}")

    def _get_tag(self, audio, tag: str, default: str) -> str:
        """Safe tag extraction with fallback"""
        try:
            value = audio.get(tag, [default])
            return value[0] if isinstance(value, list) and value else default
        except (KeyError, TypeError, IndexError):
            return default

    @property
    def duration_str(self) -> str:
        mins, secs = divmod(int(self.duration), 60)
        return f"{mins}:{secs:02d}"


# Playlist Manager
class PlaylistManager:
    def __init__(self, config: MusicConfig):
        self.config = config
        self.playlists = config.playlists
        self.current_playlist = config.data.get('current_playlist')

    def create_playlist(self, name: str):
        """Create a new empty playlist"""
        if name and name not in self.playlists:
            self.playlists[name] = []
            self.config.data['playlists'] = self.playlists
            self.config.save_config()
            return True
        return False

    def get_playlist_tracks(self, playlist_name: str) -> List[MusicTrack]:
        """Get all tracks in a playlist with path validation"""
        if playlist_name in self.playlists:
            tracks = []
            for path_str in self.playlists[playlist_name]:
                path = Path(path_str)
                if path.exists():
                    tracks.append(MusicTrack(path))
                else:
                    print(f"Missing file: {path_str}")
            return tracks
        return []

    def delete_playlist(self, name: str):
        """Delete an existing playlist"""
        if name in self.playlists:
            del self.playlists[name]
            self.config.data['playlists'] = self.playlists
            self.config.save_config()
            return True
        return False

    def add_to_playlist(self, playlist_name: str, track: MusicTrack):
        """Add a track to an existing playlist"""
        if playlist_name in self.playlists:
            track_path = str(track.path)
            if track_path not in self.playlists[playlist_name]:
                self.playlists[playlist_name].append(track_path)
                self.config.save_config()
                return True
        return False

    def remove_from_playlist(self, playlist_name: str, track_path: str):
        """Remove a track from playlist"""
        if playlist_name in self.playlists:
            try:
                self.playlists[playlist_name].remove(track_path)
                self.config.save_config()
                return True
            except ValueError:
                pass
        return False

    def get_playlist_names(self) -> List[str]:
        """Get sorted list of playlist names"""
        return sorted(self.playlists.keys())

    def clear_playlist(self, name: str):
        """Remove all tracks from a playlist"""
        if name in self.playlists:
            self.playlists[name] = []
            self.config.save_config()
            return True
        return False


# Audio Engine
class AudioBackend:
    def __init__(self, config: MusicConfig):
        self.config = config
        self.current_track: Optional[MusicTrack] = None
        self.paused = False
        self.stopped = True  # Add explicit stopped state
        self._init_pygame()
        self._setup_end_event()

    def _init_pygame(self):
        """Initialize audio system with retry logic"""
        print("Initializing audio subsystem...")
        try:
            mixer.pre_init(
                frequency=44100,
                size=-16,
                channels=self.config.data['audio_channels'],
                buffer=self.config.data['buffer_size']
            )
            mixer.init()
            pygame.init()  # Initialize pygame for event handling
            print(f"Audio initialized: {mixer.get_init()}")
            mixer.music.set_volume(self.config.volume)
        except pygame.error as e:
            print(f"Audio initialization failed: {e}")
            sys.exit(1)

    def _setup_end_event(self):
        """Set up pygame end event tracking"""
        self.END_EVENT = pygame.USEREVENT + 1
        mixer.music.set_endevent(self.END_EVENT)

    def check_events(self):
        """Check for music end events"""
        for event in pygame.event.get():
            if event.type == self.END_EVENT:
                return True
        return False

    def play(self, track: MusicTrack) -> bool:
        """Play a music file with error handling"""
        try:
            mixer.music.load(str(track.path))
            mixer.music.play()
            self.current_track = track
            self.paused = False
            self.stopped = False  # Clear stopped state
            return True
        except pygame.error as e:
            print(f"Playback error: {e}")
            return False

    def pause(self):
        """Pause playback"""
        if not self.stopped and mixer.music.get_busy():
            mixer.music.pause()
            self.paused = True

    def unpause(self):
        """Unpause playback"""
        if self.paused and not self.stopped:
            mixer.music.unpause()
            self.paused = False

    def toggle_pause(self):
        """Toggle pause state"""
        if self.stopped or not self.current_track:
            return False  # Can't pause if stopped or no track

        if self.paused:
            self.unpause()
        else:
            self.pause()
        return True

    def stop(self):
        """Stop playback completely"""
        mixer.music.stop()
        self.paused = False
        self.stopped = True
        # Don't clear current_track so we can resume from the same track

    @property
    def position(self) -> float:
        """Get current playback position"""
        if self.stopped:
            return 0
        pos = mixer.music.get_pos()
        return pos / 1000 if pos != -1 else 0

    @property
    def is_playing(self) -> bool:
        """Check if currently playing (not paused or stopped)"""
        return not self.stopped and not self.paused and mixer.music.get_busy()

    @property
    def is_paused(self) -> bool:
        """Check if currently paused"""
        return self.paused and not self.stopped

    @property
    def is_stopped(self) -> bool:
        """Check if currently stopped"""
        return self.stopped


# Modal Screens for Playlist Management
class InputScreen(ModalScreen):
    """Screen for text input"""

    def __init__(self, prompt: str):
        super().__init__()
        self.prompt = prompt

    def compose(self) -> ComposeResult:
        yield Vertical(
            Static(self.prompt, classes="prompt"),
            Input(id="input", placeholder="Enter name..."),
            Horizontal(
                Button("Submit", id="submit", variant="primary"),
                Button("Cancel", id="cancel"),
                classes="buttons"
            ),
            classes="dialog"
        )

    @on(Button.Pressed, "#submit")
    def submit(self):
        value = self.query_one("#input", Input).value.strip()
        self.dismiss(value)

    @on(Button.Pressed, "#cancel")
    def cancel(self):
        self.dismiss(None)

    @on(Input.Submitted)
    def input_submitted(self):
        self.submit()


class SelectionScreen(ModalScreen):
    """Screen for selecting from a list"""

    def __init__(self, prompt: str, options: List[str]):
        super().__init__()
        self.prompt = prompt
        self.options = options

    def compose(self) -> ComposeResult:
        yield Vertical(
            Static(self.prompt, classes="prompt"),
            Select([(opt, opt) for opt in self.options], id="select"),
            Horizontal(
                Button("Select", id="select_btn", variant="primary"),
                Button("Cancel", id="cancel"),
                classes="buttons"
            ),
            classes="dialog"
        )

    @on(Button.Pressed, "#select_btn")
    def select_option(self):
        select_widget = self.query_one("#select", Select)
        self.dismiss(select_widget.value)

    @on(Button.Pressed, "#cancel")
    def cancel(self):
        self.dismiss(None)


# Main Textual UI Application
class MusicPlayer(App):
    CSS = """
    Screen {
        layout: horizontal;
    }

    #sidebar {
        width: 25%;
        height: 100%;
        border-right: solid $primary;
    }

    #main-content {
        width: 75%;
        height: 100%;
        layout: vertical;
    }

    #playlists {
        height: 50%;
        border-bottom: solid $primary;
    }

    #library-selector {
        height: 50%;
    }

    #main-table {
        height: 70%;
    }

    #player-section {
        height: 30%;
        layout: vertical;
    }

    #player-info {
        height: 60%;
        border: solid $primary;
        padding: 1;
    }

    .prompt {
        text-align: center;
        margin-bottom: 1;
    }

    #controls {
        height: 40%;
        align: center middle;
    }

    .dialog {
        align: center middle;
        width: 50;
        height: 10;
        border: solid $primary;
        background: $surface;
        padding: 1;
    }

    .buttons {
        align: center middle;
        height: 3;
    }

    #playlist-controls {
        height: 3;
        align: center middle;
        border-bottom: solid $primary;
        padding: 1;
    }
    """

    BINDINGS = [
        ("q", "quit", "Quit"),
        ("space", "play_pause", "Play/Pause"),
        ("n", "next_track", "Next"),
        ("p", "prev_track", "Previous"),
        ("s", "stop_playback", "Stop"),
        ("c", "create_playlist", "Create Playlist"),
        ("d", "delete_playlist", "Delete Playlist"),
        ("a", "add_to_playlist", "Add to Playlist"),
        ("r", "remove_from_playlist", "Remove from Playlist"),
        ("l", "select_playlist", "Select Playlist"),
        ("z", "shuffle_playlist", "Shuffle"),
        ("shift+r", "repeat_mode", "Repeat"),
        ("ctrl+p", "play_playlist", "Play All"),
    ]

    current_playlist_name = reactive("")
    current_view_tracks = reactive([])
    shuffle_mode = reactive(False)
    repeat_mode = reactive(0)  # 0=off, 1=playlist, 2=track

    def __init__(self):
        super().__init__()
        self.config = MusicConfig()
        self.audio = AudioBackend(self.config)
        self.playlist_manager = PlaylistManager(self.config)
        self.library: List[MusicTrack] = []
        self.current_index = 0
        self.current_playlist_name = self.config.data.get('current_playlist') or ""
        self.shuffle_mode = self.config.data.get('shuffle_mode', False)
        self.repeat_mode = self.config.data.get('repeat_mode', 0)
        self._load_library()
        self.load_current_view()
        self._progress_timer = None

    def _load_library(self):
        """Optimized library scanning"""
        print("Loading music library...")
        suffixes = self.config.supported_suffixes
        seen_files = set()

        for path in self.config.music_dirs:
            if not path.exists():
                continue

            for f in path.rglob('*'):
                if f.suffix.lower() in suffixes and f not in seen_files:
                    seen_files.add(f)
                    self.library.append(MusicTrack(f))

        print(f"Found {len(self.library)} tracks")

    def load_current_view(self):
        """Load tracks for current view (library or playlist)"""
        if self.current_playlist_name:
            self.current_view_tracks = self.playlist_manager.get_playlist_tracks(self.current_playlist_name)
        else:
            self.current_view_tracks = self.library

    def compose(self) -> ComposeResult:
        yield Header()
        yield Horizontal(
            # Sidebar with playlists and library selector
            Vertical(
                Vertical(
                    Static("📚 Playlists", classes="section-header"),
                    Horizontal(
                        Button("▶️ Play All", id="play-playlist", variant="success"),
                        Button("🔀", id="shuffle", variant="primary"),
                        Button("🔁", id="repeat", variant="primary"),
                        id="playlist-controls"
                    ),
                    DataTable(id="playlists"),
                    id="playlists"
                ),
                Vertical(
                    Static("🎵 Library", classes="section-header"),
                    Button("All Music", id="show-library", variant="primary"),
                    id="library-selector"
                ),
                id="sidebar"
            ),
            # Main content area
            Vertical(
                DataTable(id="main-table"),
                Vertical(
                    Static(id="player-info"),
                    ProgressBar(id="progress"),
                    Horizontal(
                        Button("⏯️ Play", id="play"),
                        Button("⏭️ Next", id="next"),
                        Button("⏹️ Stop", id="stop"),
                        id="controls"
                    ),
                    id="player-section"
                ),
                id="main-content"
            )
        )
        yield Footer()

    def on_mount(self):
        """Initialize the UI"""
        # Setup playlist table
        self.update_playlist_table()

        # Setup main table
        main_table = self.query_one("#main-table", DataTable)
        main_table.add_columns("Title", "Artist", "Duration")
        self.update_main_table()

        # Set up progress updates
        self._progress_timer = self.set_interval(0.5, self.update_progress)

    def update_playlist_table(self):
        """Update the playlist selector table"""
        playlist_table = self.query_one("#playlists", DataTable)
        playlist_table.clear(columns=True)
        playlist_table.add_column("Name")

        for name in self.playlist_manager.playlists:
            playlist_table.add_row(name)

    def update_main_table(self):
        """Update the main track table"""
        main_table = self.query_one("#main-table", DataTable)
        main_table.clear()

        # Load all tracks
        for track in self.current_view_tracks:
            main_table.add_row(track.title, track.artist, track.duration_str)

        if self.current_view_tracks:
            main_table.move_cursor(row=0)

    def update_progress(self):
        """Update progress bar and check for track end"""
        track_ended = False

        # Check for track completion whether playing or not (in case it stopped unexpectedly)
        if self.audio.current_track and not self.audio.is_stopped:
            # Check pygame end events first
            if self.audio.check_events():
                track_ended = True
                print("DEBUG: Track ended via pygame event")

            # Check if mixer stopped playing (common when track ends)
            elif not mixer.music.get_busy() and not self.audio.paused:
                track_ended = True
                print("DEBUG: Track ended - mixer not busy and not paused")

            # Fallback: check if track finished based on position vs duration
            elif self.audio.current_track.duration > 0:
                position = self.audio.position
                duration = self.audio.current_track.duration
                mixer_busy = mixer.music.get_busy()

                print(
                    f"DEBUG: pos={position:.1f}, dur={duration:.1f}, busy={mixer_busy}, playing={self.audio.is_playing}, paused={self.audio.paused}")

                # If position is near or past the end
                if position >= duration - 0.5:
                    track_ended = True
                    print("DEBUG: Track ended via position check")

                # Additional check: if position hasn't changed and we're near the end
                if not hasattr(self, '_last_position'):
                    self._last_position = position
                    self._position_stuck_count = 0

                if abs(position - self._last_position) < 0.1:  # Position barely changed
                    self._position_stuck_count += 1
                    if self._position_stuck_count > 6 and position >= duration - 2.0:  # Stuck for 3 seconds near end
                        track_ended = True
                        print("DEBUG: Track ended via stuck position")
                else:
                    self._position_stuck_count = 0

                self._last_position = position

        # Clear events when explicitly stopped to prevent false triggers
        elif self.audio.is_stopped:
            self.audio.check_events()

        # Handle track ending
        if track_ended:
            print(f"DEBUG: Advancing to next track (repeat_mode={self.repeat_mode})")
            # Mark as stopped to prevent retriggering
            self.audio.stopped = True

            if self.repeat_mode == 2:  # Track repeat
                self.play_current_track()
            else:
                self.next_track()

        # Update progress bar
        if self.audio.current_track and (self.audio.is_playing or self.audio.is_paused):
            progress = self.query_one("#progress", ProgressBar)
            position = self.audio.position
            duration = self.audio.current_track.duration

            if duration > 0:
                progress.update(progress=position, total=duration)

        # Update button label and display
        self.update_play_button()

    def update_play_button(self):
        """Update the play/pause button label based on current state"""
        play_button = self.query_one("#play", Button)

        if self.audio.is_playing:
            play_button.label = "⏸️ Pause"
        elif self.audio.is_paused:
            play_button.label = "▶️ Resume"
        else:
            play_button.label = "▶️ Play"

    # Event Handlers
    @on(DataTable.RowSelected, "#playlists")
    def playlist_selected(self, event: DataTable.RowSelected):
        """Handle playlist selection"""
        if event.cursor_row is not None:
            playlist_table = self.query_one("#playlists", DataTable)
            cells = playlist_table.get_row_at(event.cursor_row)
            if cells:
                self.current_playlist_name = str(cells[0])
                self.config.data['current_playlist'] = self.current_playlist_name
                self.config.save_config()
                self.load_current_view()
                self.update_main_table()
                self.notify(f"Selected playlist: {self.current_playlist_name}")

    @on(DataTable.RowHighlighted, "#playlists")
    def playlist_highlighted(self, event: DataTable.RowHighlighted):
        """Handle playlist highlighting"""
        pass

    @on(Button.Pressed, "#play-playlist")
    def play_playlist(self):
        """Start playing entire playlist from beginning"""
        if self.current_view_tracks:
            self.current_index = 0
            self.play_current_track()
            self.notify("▶️ Starting playlist playback")
        else:
            self.notify("Playlist is empty!", severity="warning")

    @on(Button.Pressed, "#shuffle")
    def toggle_shuffle(self):
        """Toggle shuffle mode"""
        self.shuffle_mode = not self.shuffle_mode
        shuffle_icon = "🔀" if self.shuffle_mode else "🔀"
        self.query_one("#shuffle", Button).label = shuffle_icon
        self.config.data['shuffle_mode'] = self.shuffle_mode
        self.config.save_config()
        self.notify(f"🔀 Shuffle {'ON' if self.shuffle_mode else 'OFF'}")

    @on(Button.Pressed, "#repeat")
    def cycle_repeat(self):
        """Cycle through repeat modes"""
        self.repeat_mode = (self.repeat_mode + 1) % 3
        repeat_icons = ["🔁", "🔂", "🔁"]
        repeat_labels = ["Repeat: OFF", "Repeat: Playlist", "Repeat: Track"]

        self.query_one("#repeat", Button).label = repeat_icons[self.repeat_mode]
        self.config.data['repeat_mode'] = self.repeat_mode
        self.config.save_config()
        self.notify(repeat_labels[self.repeat_mode])

    @on(Button.Pressed, "#show-library")
    def show_library(self):
        """Show full library"""
        self.current_playlist_name = ""
        self.config.data['current_playlist'] = None
        self.config.save_config()
        self.load_current_view()
        self.update_main_table()

    @on(DataTable.RowSelected, "#main-table")
    def track_selected(self, event: DataTable.RowSelected):
        """Handle track selection (double-click or Enter key)"""
        if event.cursor_row is not None and self.current_view_tracks:
            self.current_index = event.cursor_row
            self.play_current_track()
            track = self.current_view_tracks[self.current_index]
            self.notify(f"▶️ Playing track: {track.title}")

    @on(DataTable.RowHighlighted, "#main-table")
    def track_highlighted(self, event: DataTable.RowHighlighted):
        """Handle track highlighting - update current index"""
        if event.cursor_row is not None:
            self.current_index = event.cursor_row

    @on(Button.Pressed, "#play")
    def handle_play_button(self):
        """Handle the main play/pause button with proper state logic"""
        if self.audio.is_playing:
            # Currently playing - pause it
            self.audio.pause()
            self.notify("⏸️ Paused")
        elif self.audio.is_paused:
            # Currently paused - resume
            self.audio.unpause()
            self.notify("▶️ Resumed")
        else:
            # Stopped or no track - play selected track
            self.play_selected_track()

        self.update_display()

    @on(Button.Pressed, "#next")
    def handle_next_button(self):
        """Handle next track button"""
        self.next_track()

    @on(Button.Pressed, "#stop")
    def handle_stop_button(self):
        """Handle stop button - always stops playback"""
        self.audio.stop()
        self.update_display()
        # Reset progress bar
        progress = self.query_one("#progress", ProgressBar)
        progress.update(progress=0, total=1)
        self.notify("⏹️ Stopped")

    def play_selected_track(self):
        """Play the currently highlighted track in the table"""
        if not self.current_view_tracks:
            self.notify("No tracks available!", severity="error")
            return

        # Ensure current_index is within bounds
        if self.current_index >= len(self.current_view_tracks):
            self.current_index = 0

        # Get the highlighted row from table
        main_table = self.query_one("#main-table", DataTable)
        if main_table.cursor_row is not None:
            self.current_index = main_table.cursor_row

        self.play_current_track()

    def play_current_track(self):
        """Play track at current_index"""
        if not self.current_view_tracks:
            self.notify("No tracks available!", severity="error")
            return

        if 0 <= self.current_index < len(self.current_view_tracks):
            track = self.current_view_tracks[self.current_index]
            if self.audio.play(track):
                self.update_display()
                # Update table cursor to match current track
                main_table = self.query_one("#main-table", DataTable)
                if main_table.row_count > self.current_index:
                    main_table.move_cursor(row=self.current_index)
                self.notify(f"🎵 Now playing: {track.title}")
            else:
                self.notify(f"Failed to play: {track.title}", severity="error")

    def next_track(self):
        """Play next track with shuffle/repeat support"""
        if not self.current_view_tracks:
            self.notify("No tracks available!", severity="warning")
            return

        if self.repeat_mode == 2:  # Repeat single track
            self.play_current_track()
            return

        if self.shuffle_mode:
            self.current_index = random.randint(0, len(self.current_view_tracks) - 1)
        else:
            self.current_index = (self.current_index + 1) % len(self.current_view_tracks)

        # Check if we've reached the end of playlist and repeat is off
        if self.current_index == 0 and self.repeat_mode == 0 and not self.shuffle_mode:
            self.audio.stop()
            self.update_display()
            self.notify("⏹️ End of playlist")
        else:
            self.play_current_track()

    def update_display(self):
        """Update the player info display"""
        info = self.query_one("#player-info", Static)

        if self.audio.current_track:
            track = self.audio.current_track

            # Determine status
            if self.audio.is_playing:
                status = "▶️ Playing"
            elif self.audio.is_paused:
                status = "⏸️ Paused"
            else:
                status = "⏹️ Stopped"

            # Add playlist info and track position
            playlist_info = f" | 📚 {self.current_playlist_name}" if self.current_playlist_name else " | 📚 All Music"

            # Show current track position in playlist/library
            if self.current_view_tracks:
                track_num = self.current_index + 1
                total_tracks = len(self.current_view_tracks)
                position_info = f" | 🔢 {track_num}/{total_tracks}"
            else:
                position_info = ""

            # Show shuffle/repeat status
            mode_icons = []
            if self.shuffle_mode:
                mode_icons.append("🔀")
            if self.repeat_mode == 1:
                mode_icons.append("🔂")
            elif self.repeat_mode == 2:
                mode_icons.append("🔁")
            mode_info = " | " + " ".join(mode_icons) if mode_icons else ""

            info.update(
                f"{status}{playlist_info}{position_info}{mode_info}\n"
                f"🎵 {track.title}\n"
                f"👤 {track.artist}\n"
                f"⏱ {track.duration_str}"
            )
        else:
            playlist_info = f"📚 {self.current_playlist_name}" if self.current_playlist_name else "📚 All Music"
            info.update(f"{playlist_info}\n🎵 No track selected\n\nSelect a track and press Play")

    # Keyboard Actions
    def action_play_pause(self):
        """Keyboard shortcut for play/pause"""
        self.handle_play_button()

    def action_next_track(self):
        """Keyboard shortcut for next track"""
        self.next_track()

    def action_prev_track(self):
        """Keyboard shortcut for previous track"""
        if self.current_view_tracks:
            if self.shuffle_mode:
                # Random previous track in shuffle mode
                self.current_index = random.randint(0, len(self.current_view_tracks) - 1)
            else:
                self.current_index = (self.current_index - 1) % len(self.current_view_tracks)
            self.play_current_track()

    def action_stop_playback(self):
        """Keyboard shortcut for stop"""
        self.handle_stop_button()

    def action_shuffle_playlist(self):
        """Toggle shuffle mode via keyboard"""
        self.toggle_shuffle()

    def action_repeat_mode(self):
        """Cycle repeat mode via keyboard"""
        self.cycle_repeat()

    def action_play_playlist(self):
        """Start playlist playback via keyboard"""
        self.play_playlist()

    def action_select_playlist(self):
        """Select current highlighted playlist (keyboard shortcut)"""
        playlist_table = self.query_one("#playlists", DataTable)
        if playlist_table.cursor_row is not None:
            cells = playlist_table.get_row_at(playlist_table.cursor_row)
            if cells:
                self.current_playlist_name = str(cells[0])
                self.config.data['current_playlist'] = self.current_playlist_name
                self.config.save_config()
                self.load_current_view()
                self.update_main_table()
                self.notify(f"Switched to playlist: {self.current_playlist_name}")
                self.update_display()

    def action_create_playlist(self):
        """Create a new playlist"""

        def handle_playlist_name(name: str):
            if name and self.playlist_manager.create_playlist(name):
                self.update_playlist_table()
                self.notify(f"Created playlist: {name}")
            elif name:
                self.notify(f"Playlist '{name}' already exists!", severity="error")

        self.push_screen(InputScreen("Enter playlist name:"), handle_playlist_name)

    def action_delete_playlist(self):
        """Delete selected playlist"""
        playlist_table = self.query_one("#playlists", DataTable)
        if playlist_table.cursor_row is not None:
            cells = playlist_table.get_row_at(playlist_table.cursor_row)
            if cells:
                playlist_name = str(cells[0])
                if self.playlist_manager.delete_playlist(playlist_name):
                    self.update_playlist_table()
                    if self.current_playlist_name == playlist_name:
                        self.show_library()
                    self.notify(f"Deleted playlist: {playlist_name}")

    def action_add_to_playlist(self):
        """Add current track to a playlist"""
        main_table = self.query_one("#main-table", DataTable)
        if main_table.cursor_row is None or not self.current_view_tracks:
            self.notify("No track selected!", severity="error")
            return

        track = self.current_view_tracks[main_table.cursor_row]
        options = list(self.playlist_manager.playlists.keys())

        if not options:
            self.notify("No playlists available! Create one first.", severity="error")
            return

        def handle_playlist_selection(playlist: str):
            if playlist and self.playlist_manager.add_to_playlist(playlist, track):
                self.notify(f"Added '{track.title}' to '{playlist}'")
            elif playlist:
                self.notify(f"Track already in playlist '{playlist}'!", severity="warning")

        self.push_screen(SelectionScreen("Select playlist:", options), handle_playlist_selection)

    def action_remove_from_playlist(self):
        """Remove current track from current playlist"""
        if not self.current_playlist_name:
            self.notify("Not viewing a playlist!", severity="error")
            return

        main_table = self.query_one("#main-table", DataTable)
        if main_table.cursor_row is None or not self.current_view_tracks:
            self.notify("No track selected!", severity="error")
            return

        track = self.current_view_tracks[main_table.cursor_row]
        if self.playlist_manager.remove_from_playlist(self.current_playlist_name, str(track.path)):
            self.load_current_view()
            self.update_main_table()
            self.notify(f"Removed '{track.title}' from '{self.current_playlist_name}'")

    def shuffle_current_playlist(self):
        """Shuffle the current playlist tracks order"""
        if self.current_view_tracks:
            # Create new shuffled list while maintaining original as backup
            shuffled_tracks = random.sample(self.current_view_tracks, len(self.current_view_tracks))
            self.current_view_tracks = shuffled_tracks

            # Update UI and current index
            self.current_index = 0
            self.update_main_table()
            self.notify("🔀 Playlist order shuffled")

    def on_unmount(self):
        """Clean up when app closes and save state"""
        # Save current state
        self.config.data['shuffle_mode'] = self.shuffle_mode
        self.config.data['repeat_mode'] = self.repeat_mode
        self.config.save_config()

        # Clean up timers and audio
        if self._progress_timer:
            self._progress_timer.stop()
        self.audio.stop()


if __name__ == "__main__":
    os.environ["PYGAME_HIDE_SUPPORT_PROMPT"] = "hide"
    try:
        app = MusicPlayer()
        app.run()
    except KeyboardInterrupt:
        print("\nExiting...")
        mixer.quit()
    except Exception as e:
        print(f"Application error: {e}")
        sys.exit(1)</div>
        </div>

        <div class="features">
            <h2>🌟 Key Features</h2>
            <div class="feature-grid">
                <div class="feature-card">
                    <h3>🎵 Audio Support</h3>
                    <p>Supports MP3, WAV, OGG, FLAC, and M4A audio formats with automatic metadata extraction</p>
                </div>
                <div class="feature-card">
                    <h3>📚 Playlist Management</h3>
                    <p>Create, edit, and manage custom playlists with persistent storage</p>
                </div>
                <div class="feature-card">
                    <h3>🎮 Intuitive Controls</h3>
                    <p>Full keyboard shortcuts and mouse controls for seamless music playback</p>
                </div>
                <div class="feature-card">
                    <h3>🔀 Smart Playback</h3>
                    <p>Shuffle mode, repeat options (off/playlist/track), and automatic track progression</p>
                </div>
                <div class="feature-card">
                    <h3>📊 Progress Tracking</h3>
                    <p>Visual progress bar with real-time position updates and track information</p>
                </div>
                <div class="feature-card">
                    <h3>🎨 Modern UI</h3>
                    <p>Built with Textual framework for a beautiful terminal-based interface</p>
                </div>
            </div>
        </div>

        <div class="download-section">
            <h2 style="margin-bottom: 2rem; font-size: 2.5rem; color: #00ff41; text-shadow: 0 0 20px #00ff41;">Ready to Rock Your Terminal?</h2>
            <a href="https://drive.google.com/file/d/10dJ3ue_Utsm_DxfWEdFpA0pwMMijkv1l/view?usp=sharing" class="download-btn" target="_blank">
                📥 Download PyMPC
            </a>
            <p style="margin-top: 1rem; color: #66ff66; font-size: 1.1rem;">Windows executable - no installation required</p>
        </div>

        <div class="specs">
            <h3>🔧 System Requirements</h3>
            <ul>
                <li>Windows 10 or later (64-bit)</li>
                <li>Audio output device (speakers/headphones)</li>
                <li>Minimum 100MB free disk space</li>
                <li>Terminal/Command Prompt access</li>
                <li>Music files in supported formats (MP3, FLAC, OGG, WAV, M4A)</li>
            </ul>
        </div>

        <div class="specs">
            <h3>⚡ Quick Start</h3>
            <ul>
                <li>Download PyMPC.exe from the link above</li>
                <li>Extract to your preferred folder</li>
                <li>Double-click PyMPC.exe or run from command prompt</li>
                <li>Wait a moment for startup (loads your music library)</li>
                <li>Use arrow keys to navigate, Enter to select tracks</li>
            </ul>
        </div>

        <div class="specs">
            <h3>🎹 Keyboard Shortcuts</h3>
            <ul>
                <li>SPACE - Play/Pause current track</li>
                <li>N - Next track | P - Previous track</li>
                <li>S - Stop playback | Q - Quit application</li>
                <li>C - Create playlist | D - Delete playlist</li>
                <li>A - Add to playlist | R - Remove from playlist</li>
                <li>Z - Toggle shuffle | Shift+R - Cycle repeat modes</li>
            </ul>
        </div>

        <footer style="text-align: center; padding: 3rem 0; color: #666; border-top: 1px solid #00ff41; margin-top: 3rem;">
            <p style="color: #66ff66;">PyMPC - Built for music lovers who live in the terminal</p>
            <p style="margin-top: 1rem; color: #00ff41;">🎵 Happy listening! 🎵</p>
        </footer>
    </div>

    <script>
        function copyCode() {
            const codeBlock = document.getElementById('codeBlock');
            const textToCopy = codeBlock.textContent;
            
            navigator.clipboard.writeText(textToCopy).then(() => {
                const button = document.querySelector('.copy-btn');
                const originalText = button.innerHTML;
                button.innerHTML = '✅ Copied!';
                button.style.background = 'rgba(46, 204, 113, 0.8)';
                button.style.color = '#fff';
                
                setTimeout(() => {
                    button.innerHTML = originalText;
                    button.style.background = 'rgba(0, 0, 0, 0.3)';
                    button.style.color = '#000';
                }, 2000);
            }).catch(() => {
                // Fallback for older browsers
                const textarea = document.createElement('textarea');
                textarea.value = textToCopy;
                document.body.appendChild(textarea);
                textarea.select();
                document.execCommand('copy');
                document.body.removeChild(textarea);
                
                const button = document.querySelector('.copy-btn');
                const originalText = button.innerHTML;
                button.innerHTML = '✅ Copied!';
                button.style.background = 'rgba(46, 204, 113, 0.8)';
                button.style.color = '#fff';
                
                setTimeout(() => {
                    button.innerHTML = originalText;
                    button.style.background = 'rgba(0, 0, 0, 0.3)';
                    button.style.color = '#000';
                }, 2000);
            });
        }

        // Matrix-like falling characters effect
        function createMatrixEffect() {
            const chars = '01♪♫🎵🎶';
            const matrixElement = document.createElement('div');
            matrixElement.style.cssText = `
                position: fixed;
                top: -10px;
                left: ${Math.random() * 100}vw;
                color: rgba(0, 255, 65, 0.1);
                font-size: 14px;
                font-family: monospace;
                pointer-events: none;
                z-index: -1;
                animation: matrixFall 5s linear forwards;
            `;
            matrixElement.textContent = chars[Math.floor(Math.random() * chars.length)];
            document.body.appendChild(matrixElement);

            setTimeout(() => {
                matrixElement.remove();
            }, 5000);
        }

        // Add matrix fall animation
        const style = document.createElement('style');
        style.textContent = `
            @keyframes matrixFall {
                to {
                    transform: translateY(100vh);
                    opacity: 0;
                }
            }
        `;
        document.head.appendChild(style);

        // Enhanced interactive effects
        document.addEventListener('DOMContentLoaded', function() {
            // Animate floating music notes
            setInterval(() => {
                const notes = document.querySelectorAll('.music-note');
                notes.forEach(note => {
                    if (Math.random() > 0.7) {
                        note.style.transform = `translateY(-20px) rotate(${Math.random() * 360}deg)`;
                        setTimeout(() => {
                            note.style.transform = '';
                        }, 500);
                    }
                });
            }, 3000);

            // Feature card interactions
            const featureCards = document.querySelectorAll('.feature-card');
            featureCards.forEach(card => {
                card.addEventListener('click', function() {
                    this.style.transform = 'scale(0.95) translateY(-5px)';
                    setTimeout(() => {
                        this.style.transform = '';
                    }, 150);
                });
            });

            // Download button hover effects
            const downloadBtn = document.querySelector('.download-btn');
            if (downloadBtn) {
                downloadBtn.addEventListener('mouseenter', function() {
                    this.style.background = 'linear-gradient(45deg, #66ff66, #00ff41)';
                });
                
                downloadBtn.addEventListener('mouseleave', function() {
                    this.style.background = 'linear-gradient(45deg, #00ff41, #66ff66)';
                });
            }

            // Create matrix effect periodically
            setInterval(createMatrixEffect, 500);
        });
    </script>
</body>
</html>
